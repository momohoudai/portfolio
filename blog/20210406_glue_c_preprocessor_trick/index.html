<html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.w3schools.com/w3css/4/w3.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro"><link rel=stylesheet href=/css/common.css><link rel=stylesheet href=/css/syntax.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>Gerald's Website</title>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div class=container><div class=profile><h1>momo</h1><h2>just another place for me to talk about things i like</h2></div><div class=nav><a href=/>Home</a>
<a class=nav-target href=/blog>Blog</a>
<a href=/portfolio>Portfolio</a>
<a href=https://twitter.com/momohoudai>X</a></div><div class=tag-nav><a class=tag-nav-target href=/blog>all</a>
<a href=/tags/tech>tech</a>
<a href=/tags/irl>irl</a>
<a href=/tags/design>design</a></div><hr><div class=blog-body><div class=blog-title>[C/C++] The 'Glue' Preprocessor Trick</div><div class=blog-date-tag-wrapper><div class=blog-date><time datetime=2021-04-06T12:00:00+08:00>Apr 6, 2021</time></div><div class=blog-tag>tech</div></div><div class=blog-body><p>Macro tricks are rare to find nowadays.
Sometimes, I would code and <em>know</em> of a trick but had forgotten how to go about implementing it because they can look as arcane as Template Metaprogramming.
Hopefully, I can document some of my knowledge of these tricks in this blog.
Here, I will introduce what I call the &lsquo;Glue&rsquo; macro trick.</p><p>Let&rsquo;s start with a problem.
I&rsquo;ll use a simple example from my project.
Suppose I have a simple struct that represents a string, and provide a simple function that acts as a constructor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>string_t</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>string_t <span style=color:#a6e22e>create_string</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> buffer, <span style=color:#66d9ef>unsigned</span> count) {
</span></span><span style=display:flex><span>    string_t ret <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    ret.buffer <span style=color:#f92672>=</span> buffer;
</span></span><span style=display:flex><span>    ret.count <span style=color:#f92672>=</span> Count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the way to easily initialize such a struct might be something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>string_t str <span style=color:#f92672>=</span> create_string(temp_buffer, <span style=color:#ae81ff>256</span>);
</span></span></code></pre></div><p>It&rsquo;s terribly unwieldy. We might end up in an ugly scenario where it looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer1[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>string_t str1 <span style=color:#f92672>=</span> create_string(temp_buffer1, <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer2[<span style=color:#ae81ff>128</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>string_t str2 <span style=color:#f92672>=</span> create_string(temp_buffer2, <span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer3[<span style=color:#ae81ff>64</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>string_t str3 <span style=color:#f92672>=</span> create_string(temp_buffer3, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer4[<span style=color:#ae81ff>32</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>string_t Str4 <span style=color:#f92672>=</span> create_string(temp_buffer4, <span style=color:#ae81ff>32</span>);
</span></span></code></pre></div><p>But we see some hope!
There is a pattern in the code so we decide to use macro concatenation to help us make the code look cleaner.
We hope to achieve something like below which will expand to the code above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>create_stack_string(str1, <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>create_stack_string(str2, <span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span>create_stack_string(str3, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>create_stack_string(Str4, <span style=color:#ae81ff>32</span>);
</span></span></code></pre></div><p>So now, we will try to implement the macro.
We start off naively by trying to define a macro based on what we want to substitute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define create_stack_string(name, num) \ 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> temp_buffer[Num] <span style=color:#f92672>=</span> {}; <span style=color:#960050;background-color:#1e0010>\</span> 
</span></span><span style=display:flex><span>string_t name <span style=color:#f92672>=</span> create_string(temp_buffer, num)
</span></span></code></pre></div><p>This would be good for one call, but subsequent calls would cause an error because <code>temp_buffer</code> would be redefined. What we kind of want is some kind of unique id to attach to <code>temp_buffer</code>. A common way is to use the <code>__LINE__</code> macro definition that will evaluate to the document&rsquo;s line number. It might not work for all cases, but for this case, it is good enough because it&rsquo;s impossible to have two <code>temp_buffers</code> exist in the same line AND scope.</p><p>So we just concatenate <code>__LINE__</code> to <code>temp_buffer</code>. Simple right?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#75715e>#define create_stack_string(Name, Num) char temp_buffer##__LINE__[Num] = {}; string_t Name = create_string(temp_buffer##__LINE__, Num)
</span></span></span></code></pre></div><p>Sadly, this does not work.
According to be C99 specification in section 6.10.3.3, line 2:</p><p><code>If, in the replacement list of a function-like macro, a parameter is immediately precededor followed by a ## preprocessing token, the parameter is replaced by the corresponding argumentâ€™s preprocessing token sequence; however, if an argument consists of no preprocessing tokens, the parameter is replaced by a placemarker preprocessing token instead.</code></p><p>That means that when <code>##</code> is encountered, any macros on the left and right of it will not be evaluated.
That means that this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> create_stack_string(str1, <span style=color:#ae81ff>256</span>);
</span></span></code></pre></div><p>Would evaluate to something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>char</span> temp_buffer__LINE__[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> {}; string_t Name <span style=color:#f92672>=</span> create_string(temp_buffer__LINE__, <span style=color:#ae81ff>256</span>)
</span></span></code></pre></div><p>Which means that we are back to square one.
To solve this, a simple indirection trick can be used to <strong>force</strong> the <code>__LINE__</code> macro to evaluate (and by extension, any macro you want to evaluate that is part of an argument for the macro concatenation <code>##</code> syntax).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define glue_(a,b) a##b
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define glue(a,b) glue_(a,b)
</span></span></span></code></pre></div><p>Then we use the <code>glue</code> macro like this to solve our problem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define create_stack_string(name, num) char glue(temp_buffer,__LINE__)[num] = {}; string_t name = create_string(glue(temp_buffer,__LINE__), num)
</span></span></span></code></pre></div><p>For clarity, the macro expansion is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>create_stack_string(str1, <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>create_stack_string(str2, <span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span>create_stack_string(str3, <span style=color:#ae81ff>64</span>);
</span></span></code></pre></div><p>expands to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Expand 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>glue</span>(temp_buffer,__LINE__)[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> {}; string_t str1 <span style=color:#f92672>=</span> create_string(glue(temp_buffer,__LINE__), <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>glue</span>(temp_buffer,__LINE__)[<span style=color:#ae81ff>128</span>] <span style=color:#f92672>=</span> {}; string_t str2 <span style=color:#f92672>=</span> create_string(glue(temp_buffer,__LINE__), <span style=color:#ae81ff>128</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> glue(temp_buffer,__LINE__)[<span style=color:#ae81ff>64</span>] <span style=color:#f92672>=</span> {}; string_t str3 <span style=color:#f92672>=</span> create_string(glue(temp_buffer,__LINE__), <span style=color:#ae81ff>64</span>)
</span></span></code></pre></div><p>expands to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>glue_</span>(temp_buffer,<span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> {}; string_t str1 <span style=color:#f92672>=</span> create_string(glue(temp_buffer,<span style=color:#ae81ff>1</span>), <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>glue_</span>(temp_buffer,<span style=color:#ae81ff>2</span>)[<span style=color:#ae81ff>128</span>] <span style=color:#f92672>=</span> {}; string_t str2 <span style=color:#f92672>=</span> create_string(glue(temp_buffer,<span style=color:#ae81ff>2</span>), <span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>glue_</span>(temp_buffer,<span style=color:#ae81ff>3</span>)[<span style=color:#ae81ff>64</span>] <span style=color:#f92672>=</span> {}; string_t str3 <span style=color:#f92672>=</span> create_string(glue(temp_buffer,<span style=color:#ae81ff>3</span>), <span style=color:#ae81ff>64</span>);
</span></span></code></pre></div><p>which will finally expand to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer1[<span style=color:#ae81ff>256</span>] <span style=color:#f92672>=</span> {}; string_t str1 <span style=color:#f92672>=</span> create_string(temp_buffer1, <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer2[<span style=color:#ae81ff>128</span>] <span style=color:#f92672>=</span> {}; string_t str2 <span style=color:#f92672>=</span> create_string(temp_buffer2, <span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> temp_buffer3[<span style=color:#ae81ff>64</span>] <span style=color:#f92672>=</span> {}; string_t str3 <span style=color:#f92672>=</span> create_string(temp_buffer3, <span style=color:#ae81ff>64</span>);
</span></span></code></pre></div><p>The trick is, in the end, not very complicated.
It is just to get around the rather unintuitive specification in the C99 standard that states that arguments for <code>##</code> would not be evaluated.</p></div></div></div><footer>Powered By Hugo | v2.0 | Â© 2024 Momoko Mopiko</footer></body></html>