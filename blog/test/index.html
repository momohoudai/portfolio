<html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.w3schools.com/w3css/4/w3.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro"><link rel=stylesheet href=/css/common.css><link rel=stylesheet href=/css/syntax.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>Gerald's Website</title>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div class=container><div class=profile><h1>momo</h1><h2>just another place for me to talk about things i like</h2></div><div class=nav><a href=/>Home</a>
<a class=nav-target href=/blog>Blog</a>
<a href=/portfolio>Portfolio</a>
<a href=https://twitter.com/momohoudai>X</a></div><div class=tag-nav><a class=tag-nav-target href=/blog>all</a>
<a href=/tags/tech>tech</a>
<a href=/tags/irl>irl</a>
<a href=/tags/design>design</a>
<a href=/tags/logs>logs</a></div><hr><div class=blog-body><div class=blog-title>A small shortcoming of return-by-value</div><div class=blog-date-tag-wrapper><div class=blog-date><time datetime=2023-11-28T12:00:00+08:00>Nov 28, 2023</time></div><div class=blog-tag>tech</div></div><div class=blog-body><p>This post is just to document for my own reference the math that went behind the transformations (scale, rotate, translate) of the overlay pixel shader I wrote for Reshade.
It turns out that it was a little more tricky than I initially expected.</p><p>The main point of this pixel shader is to allow users to freely place a texture on the screen.
The idea is that this shade will eventually expand to allow blend modes, and then hopefully we can start using it like layers in Photoshop.</p><p>(I honestly have no idea if it&rsquo;s worth doing this, but hey, this is mostly for my education too because I have not written pixel shaders and to me it&rsquo;s a lacking part of my experience as a programmer that I want to fill for the longest time).</p><h1 id=understanding-the-parameters>Understanding the parameters</h1><p>The first thing is to understand what parameters I have avaliable to me.
Since this is the pixel shader, the main things given to me are:</p><ul><li>Screen buffer width in pixels.</li><li>Screen buffer height in pixels.</li><li>Current UV coordinate that indicates the current pixel that is going through the shader.</li><li>A way to sample the overlay texture given a UV.</li></ul><p>The input parameters I have for the users are:</p><ul><li>Width of the overlay in pixels</li><li>Height of the overlay in pixels</li><li>X position of the overlay in pixels</li><li>Y position of the overlay in pixels</li><li>Rotation of the overlay in degrees.</li></ul><p>This means that the user can just say &ldquo;I want the a texture that is 100x100 px, at x = 100, y = 200, and rotated 90 degrees&rdquo;.</p><p>Seems like a trivial problem in any frontend work.
You&rsquo;d usually apply a scale * rotation * translation matrix on all the vertices of your object (sprite, mesh or otherwise) and it will just work.</p><p>Except that I don&rsquo;t have my object or its vertices.
Those don&rsquo;t exist anywhere in the pixel shader.</p><p>Basically, for each pixel on the screen buffer, I have to find the corresponding UV to sample out a color from the overlay texture.</p><p>We&rsquo;ll first define the screen buffer&rsquo;s UV given to us in the pixel shader as follows:</p><p>$ \vec{b} = \begin{bmatrix} s_u \\ s_v \\ 1 \end{bmatrix} $</p><p>As a recap, UV coordinates are normalized coordinates of a texture, with it&rsquo;s origin usually at the top left. U represents the value on the X axis going towards the right while V represents the value on the Y going downwards.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span> 
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>The aim of the transformation matrices we are doing to form will the current UV coordinates of the screen buffer and some how map it to the corresponding UV coordinates of the overlay texture.</p><h1 id=scale>Scale</h1><p>Scale is interesting but straightforward.
The first thing to understand is that if we simply double the screen buffer $ \vec{b} $ and use the resultant UV to sample our overlay&rsquo;s texture, it will cover the upperleft quadrant of the screen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span> 
</span></span><span class=line><span class=cl>    <span class=o>|</span><span class=n>xxx</span>   <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span><span class=n>xxx</span>   <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>where</span> <span class=sc>&#39;x&#39;</span> <span class=n>is</span> <span class=n>the</span> <span class=n>part</span> <span class=n>covered</span> <span class=n>by</span> <span class=n>the</span> <span class=n>overlay</span>
</span></span></code></pre></div><p>Intuitively you would think that halfing would produce this result instead of doubling, but if you consider how UV works, you will realize that the opposite is actually true.</p><p>As an example, let&rsquo;s say we are at the halfway mark of the screen buffer, at 0.5 (It doesn&rsquo;t matter whether we are talking about width or height; the same concept can be applied to both).
At 0.5 of the screen buffer, the parts of the overlay&rsquo;s texture we want to sample are the ends of the overlay.
That is, when the UV we get from the screen buffer is at:</p><p>$ \vec{b} = \begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} $</p><p>Then we want to sample the overlay&rsquo;s texture&rsquo;s UV at:</p><p>$ \vec{o} = \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix} $</p><p>With that in mind, we can simply derive the the matrix that transform $ \vec{b} $ to $ \vec{o} $.
All we have to do is to figure out the function f() such that:</p><p>$
\begin{bmatrix} f(s_x) & 0 & 0 \\ 0 & f(s_y) & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}
$</p><p>That is, given 0.5 as input for $ s_x $ and $ s_y $, figure out:</p><p>$
\begin{bmatrix} f(0.5) & 0 & 0 \\ 0 & f(0.5) & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}
$</p><p>Turn out this is simply:</p><p>$
\begin{bmatrix} 1/0.5 & 0 & 0 \\ 0 & 1/0.5 & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}
$</p><p>And thus our final scale matrix is:</p><p>$
\begin{bmatrix} 1/s_x & 0 & 0 \\ 0 & 1/s_y & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}
$</p><p>Thus if we want the overlay to be half the screen&rsquo;s width and height such that it&rsquo;s covering a quarter of the screen, both $ s_x $ and $ s_y $ would need to be 0.5 (representing half), which will in turn evaluate to 2, which is what we want!
Kind of counter intuiaive since suddenly this looks like an inverse scale matrix instead of the normal scale matrix, but the math does check out!</p><p>The last part of the ingredient is scaling the overlay to the exact pixel size.
This is trival now that we have our &lsquo;scale&rsquo; matrix.
Let&rsquo;s say for width, we intuitively want to divide by the full buffer width before multiplying by the target of the overlay.
With our matrix, we will set that as $ s_x $ and the matrix will reverse the operation such that it&rsquo;s correct!</p><p>Okay, let&rsquo;s watch it in action. Say my buffer width and height is both 100 pixels and my target texture width is both 50 pixles.
We simply do:</p><p>$ s_x = 50 / 100 = 0.5 $</p><p>$ s_y = 50 / 100 = 0.5 $</p><p>We apply the matrix onto&mldr;say when given screen buffer&rsquo;s UV $ \vec{b} $ is at the midpoint of the screen:</p><p>$ \vec{b} = \begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} $</p><p>$
\begin{bmatrix} 1/0.5 & 0 & 0 \\ 0 & 1/0.5 & 0 \\ 0 & 0 & 1 \end{bmatrix} \vec{b} = \vec{o} $</p><p>$
\begin{bmatrix} 1/0.5 & 0 & 0 \\ 0 & 1/0.5 & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} = \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix} $</p><p>Which is correct! Horray!</p><h1 id=translation>Translation</h1><p>The next matrix is one that &lsquo;moves&rsquo; the overlay.
Assuming that the overlay start from origin like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span> 
</span></span><span class=line><span class=cl>    <span class=o>|</span><span class=n>xxx</span>   <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span><span class=n>xxx</span>   <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>Let&rsquo;s say we want to shift the overlay such that it start from the center, which would give us this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span> 
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>      <span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>   <span class=n>xxx</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span>   <span class=n>xxx</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>--------</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>This means that when the given screen buffer UV is:</p><p>$ \vec{b} = \begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} $</p><p>we want to sample the overlay&rsquo;s UV at:</p><p>$ \vec{o} = \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} $</p><p>This is looks like just a trival translation, but what&rsquo;s interesting is that, like the scale matrix, we end up needing to do a reverse translation matrix.</p><p>Similar to the scale matrix example above, we want to find the translation matrix that does this:</p><p>$
\begin{bmatrix} 1 & 0 & f(t_x) \\ 0 & 1 & f(t_y) \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
$</p><p>Let&rsquo;s try by substituting the values we have for $ t_x $ and $ t_y $:</p><p>$
\begin{bmatrix} 1 & 0 & f(0.5) \\ 0 & 1 & f(0.5) \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
$</p><p>We can then figure out f() and find our translation matrix:</p><p>$
\begin{bmatrix} 0 & 0 & -0.5 \\ 0 & 0 & -0.5 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
$</p><p>Which bring us to our final matrix:</p><p>$
\begin{bmatrix} 0 & 0 & -t_x \\ 0 & 0 & -t_y \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 0.5 \\ 0.5 \\ 1 \end{bmatrix} =
\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
$</p><h1 id=rotation>Rotation</h1><p>Rotation was really weird to figure out.
Let&rsquo;s think about rotation for a bit.
When we rotate, say, an image regularly 90 degrees, the aspect ratio actually changes.</p><p>So say something that&rsquo;s 4:2 like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>xxxx</span>
</span></span><span class=line><span class=cl><span class=n>yyyy</span>
</span></span></code></pre></div><p>Once rotated, the aspect ratio will naturally change because&mldr;well it rotated!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>xy</span>
</span></span><span class=line><span class=cl><span class=n>xy</span>
</span></span><span class=line><span class=cl><span class=n>xy</span>
</span></span><span class=line><span class=cl><span class=n>xy</span>
</span></span></code></pre></div><p>This behaviour does not apply to UVs.
If you have a 3:2 texture with it&rsquo;s UV rotated, it will still be 4:2!
So basically if we rotate a texture&rsquo;s UV by 90 degrees, we will get something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>xxyy</span>
</span></span><span class=line><span class=cl><span class=n>xxyy</span>
</span></span></code></pre></div><p>Okay the ascii drawing above doesn&rsquo;t paint the full picture.
I&rsquo;m too lazy to draw an image and upload it but imagine that after rotating, not only is the image rotated, it is squished and stretched to fill the original image&rsquo;s width and height.</p><p>This is, of course, after applying the good old rotation matrix:</p><p>$
\begin{bmatrix} cos(\theta) & -sin(\theta) & 0 \\ sin(\theta) & cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}
$</p><p>This means that not only do we have to rotate, we technically have to do some kind of scaling as well.
At 0, and 180 degrees, we want to maintain the original aspect ratio, but at 90 and 270, it should be the scaled such that the aspect ratio reverses!
That is, at 0 degrees, if we were at 4:2 ratio, then at 90 degrees, we need to apply a scale such that it becomes 2:4.
(In between degrees will need to scale accordingly too of course).</p><p>Thankfully, we coud make use of how the rotation matrix work.
Remember how cosine and sin works.
For our example, we need to know that:</p><p>$ cos(0) $ gives 1, $ cos(90) $ gives 0</p><p>$ sin(0) $ gives 0, $ sin(90) $ gives 1</p><p>Next, observe what happens when we multiply the rotation maxtrix to a UV point:</p><p>$
\begin{bmatrix} cos(\theta) & -sin(\theta) & 0 \\ sin(\theta) & cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} x \\ y \\ 1 \end{bmatrix} =
\begin{bmatrix} x cos(\theta) - y sin(\theta) \\ x sin(\theta) + y cos(\theta) \\ 1 \end{bmatrix}
$</p><p>At 0 degrees, this would be:</p><p>$
\begin{bmatrix} x cos(0) - y sin(0) \\ x sin(0) + y cos(0) \\ 1 \end{bmatrix} =
\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
$</p><p>Obviously nothing changed.
How about 180 degrees?</p><p>$
\begin{bmatrix} x cos(180) - y sin(180) \\ x sin(180) + y cos(180) \\ 1 \end{bmatrix} =
\begin{bmatrix} -x \\ -y \\ 1 \end{bmatrix}
$</p><p>This is correct; the UV will be flipped only on the x and y axis.
Note that we are rotating about the origin so it does go offscreen, so you do have to do some translation to bring the UV back to the range of 0 - 1.</p><p>$
\begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 1 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} x \\ y \\ 1 \end{bmatrix} =
\begin{bmatrix} -x + 1 \\ -y + 1 \\ 1 \end{bmatrix}
$</p><p>This means that:</p><p>When Screen buffer&rsquo;s UV = $ \begin{bmatrix} 0 \\ 0 \end{bmatrix} $ -> Texture&rsquo;s UV = $ \begin{bmatrix} 1 \\ 1 \end{bmatrix} $.</p><p>When Screen buffer&rsquo;s UV = $ \begin{bmatrix} 0.5 \\ 0.5 \end{bmatrix} $ -> Texture&rsquo;s UV = $ \begin{bmatrix} 0.5 \\ 0.5 \end{bmatrix} $.</p><p>When Screen buffer&rsquo;s UV = $ \begin{bmatrix} 1 \\ 1 \end{bmatrix} $ -> Texture&rsquo;s UV = $ \begin{bmatrix} 0 \\ 0 \end{bmatrix} $.</p><p>This will give us an upside down texture on the screen, which is correct!</p><p>Okay now for the exciting part, 90 degrees:</p><p>$
\begin{bmatrix} x cos(90) - y sin(90) \\ x sin(90) + y cos(90) \\ 1 \end{bmatrix} =
\begin{bmatrix} -y \\ x \\ 1 \end{bmatrix}
$</p><p>Because we rotate it clockwise from the origin (yes, we used a counter-clockwise matrix but remember that x goes left and y goes down), we will have to translate left so that it is on the screen.</p><p>$
\begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} -y \\ x \\ 1 \end{bmatrix} =
\begin{bmatrix} -y + 1 \\ x \\ 1 \end{bmatrix}
$</p><p>Let&rsquo;s imagine what happens.</p><p>When Screen buffer&rsquo;s UV = $ \begin{bmatrix} 0 \\ 0 \end{bmatrix} $ -> Texture&rsquo;s UV = $ \begin{bmatrix} 1 \\ 0 \end{bmatrix} $.</p><p>When Screen buffer&rsquo;s UV = $ \begin{bmatrix} 0.5 \\ 0.5 \end{bmatrix} $ -> Texture&rsquo;s UV = $ \begin{bmatrix} 0.5 \\ 0.5 \end{bmatrix} $.</p><p>When Screen buffer&rsquo;s UV = $ \begin{bmatrix} 1 \\ 1 \end{bmatrix} $ -> Texture&rsquo;s UV = $ \begin{bmatrix} 0 \\ 1 \end{bmatrix} $.</p><p>The math checks out; the texture does get rotated but remember that this is wrong.
It is bound to the original aspect ratio, so what we end up is a texture that&rsquo;s squished on the y-axis and stretched on the x-axis!</p><p>The solution is simple in concept: We need to scale such that we flip the aspect ratio for the 90 degrees case.
If we solve this, it will work for any other intermediary angle (I can solve for 30 degrees or 45 degrees but this article has run long enough).</p><p>Here&rsquo;s how I see the problem and solve it.
We look at the 90 degree case again, ignoring the translation matrix for now:</p><p>$
\begin{bmatrix} -y \\ x \\ 1 \end{bmatrix}
$</p><p>Ideally, we want it to be:</p><p>$
\begin{bmatrix} -y / b_w * b_h \\ x \\ 1 \end{bmatrix}
$</p></div></div></div><footer>Powered By Hugo | v2.0 | © 2022 Gerald Wong</footer></body></html>