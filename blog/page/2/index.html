<html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.w3schools.com/w3css/4/w3.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro"><link rel=stylesheet href=/css/common.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>Gerald's Website</title></head><body><div class=container><div class=profile><h1>momo</h1><h2>just another place for me to talk about things i like</h2></div><div class=nav><a href=/>Home</a>
<a href=/blog>Blog</a>
<a href=/portfolio>Portfolio</a>
<a href=/fun>Fun</a></div><hr><div class=blog-container><div class=blog-body><article class=blog-list-content><header><h1 class=blog-list-content-title><a href=/blog/20210801_perspective_projection_matrix/>Perspective Projection Matrix</a></h1><h4 class=blog-list-content-date><time datetime=2021-08-01T12:00:00+08:00>Aug 1, 2021</time></h4></header><section><p>I was searching around internet for a full derivation for the 3D Perspective Projection Matrix to apply to my handmade software renderer and I was surprised by how little information I could find about it. That prompted me to write this post, to document the derivation of the matrix, at least in my own eyes.</p></section><hr class=blog-list-content-seperator></article><article class=blog-list-content><header><h1 class=blog-list-content-title><a href=/blog/20210428_circle_line_collision/>Circle to Finite Line Collision</a></h1><h4 class=blog-list-content-date><time datetime=2021-07-04T12:00:00+08:00>Jul 4, 2021</time></h4></header><section><p>Recently, I had to derive this particular collision detection algorithm for my bullet hell genre game. It&rsquo;s an interesting algorithm that can be expanded to deal with the &lsquo;moving circle vs static circle&rsquo; and &lsquo;moving circle vs moving circle&rsquo; problems.</p></section><hr class=blog-list-content-seperator></article><article class=blog-list-content><header><h1 class=blog-list-content-title><a href=/blog/20210406_glue_c_preprocessor_trick/>'Glue' C-preprocessor trick</a></h1><h4 class=blog-list-content-date><time datetime=2021-04-06T12:00:00+08:00>Apr 6, 2021</time></h4></header><section><p>Macro tricks are rare to find nowadays. Sometimes, I would code and <em>know</em> of a trick but had forgotten how to go about implementing it because they can look as arcane as Template Metaprogramming. Hopefully, I can document some of my knowledge of these tricks in this blog. Here, I will introduce what I call the &lsquo;Glue&rsquo; macro trick.</p></section><hr class=blog-list-content-seperator></article><article class=blog-list-content><header><h1 class=blog-list-content-title><a href=/blog/20210324_shortcomings_of_return_by_value_c_style_constructors/>A small shortcoming of return-by-value</a></h1><h4 class=blog-list-content-date><time datetime=2021-03-24T12:00:00+08:00>Mar 24, 2021</time></h4></header><section><p>Recently, while coding on my personal C/C++ game engine project, I ran into a surprising shortcoming of functions that returns an object by value. This was when I was still trying to keep things consistant in my project and went for a functional-programming style.</p></section><hr class=blog-list-content-seperator></article></div></div></div><footer>Powered By Hugo | v2.0 | Â© 2022 Gerald Wong</footer></body></html>