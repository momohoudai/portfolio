<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/construction.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title></head><body><div id=container><div id=title>tech</div><div class=box><h1>A small shortcoming of return-by-value</h1><div><time datetime=2021-03-24T12:00:00+08:00><h2>Mar 24, 2021</h2></time></div><div><p>Recently, while coding on my personal C/C++ game engine project, I ran into a surprising shortcoming of functions that returns an object by value. This was when I was still trying to keep things consistant in my project and went for a functional-programming style.</p><p>Consider that there are generally two simple ways to modify an object in C/C++ through plain functions.</p><p>Returning by value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>v2f</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> x, y; 
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>v2f <span style=color:#a6e22e>CreateV2f</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v2f { x, y };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Usage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>v2f Vec <span style=color:#f92672>=</span> CreateV2f(<span style=color:#ae81ff>1.f</span>, <span style=color:#ae81ff>2.f</span>);
</span></span></code></pre></div><p>Modifying by pointer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>v2f</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> x, y; 
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitV2f</span>(v2f<span style=color:#f92672>*</span> Vec, <span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y) {
</span></span><span style=display:flex><span>    Vec<span style=color:#f92672>-&gt;</span>x <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>    Vec<span style=color:#f92672>-&gt;</span>y <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Usage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>v2f Vec <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>InitV2f(<span style=color:#f92672>&amp;</span>Vec, <span style=color:#ae81ff>1.f</span>, <span style=color:#ae81ff>2.f</span>);
</span></span></code></pre></div><p>We can spend hours arguing about which one is better, but optimization and code readability aside, we can all agree that both functions generally does the same thing, at a relatively good speed.</p><p>So I have been using both styles interchangably for awhile now. Some scenarios, I feel like the first method is better while other times, the second feels better. Generally, it felt like both methods are interchangable. I ended up just going for the return-by-value style because copy elision is a thing. I did not profile the performance differences between the two styles so call it &lsquo;premature optimization&rsquo; if you will, but I just wanted some consistency in my code.</p><p>However I found a <em>slightly</em> unexpected shortcoming of the return-by-value method. Consider the scenario:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Simple lightweight &#39;string&#39; object.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>String</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cap;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>String <span style=color:#a6e22e>CreateString</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> buffer, <span style=color:#66d9ef>int</span> cap) {
</span></span><span style=display:flex><span>    String ret <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    ret.data <span style=color:#f92672>=</span> buffer;
</span></span><span style=display:flex><span>    ret.cap <span style=color:#f92672>=</span> cap;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StringWithBuffer</span> {
</span></span><span style=display:flex><span>    u8 buffer[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    String str; 
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>StringWithBuffer <span style=color:#a6e22e>CreateStringWithBuffer</span>() {
</span></span><span style=display:flex><span>    StringWithBuffer ret <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    ret.str <span style=color:#f92672>=</span> CreateString(ret.buffer, <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret; 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Usage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>StringWithBuffer foo <span style=color:#f92672>=</span> CreateStringWithBuffer();
</span></span><span style=display:flex><span><span style=color:#75715e>// foo.str.data will not point to foo.str.buffer!
</span></span></span></code></pre></div><p>After calling <code>CreateStringWithBuffer()</code>, <code>foo.str.data</code> member will be pointing at an invalid address and not <code>foo.buffer</code>! This is obvious when you work out what happened step by step. Within <code>CreateStringWithBuffer()</code>, <code>ret.str.data</code> would end up correctly pointing to <code>ret.buffer</code>. However, <code>ret</code> is actually a temporary object, so <code>ret.buffer</code> will naturally become invalid after the function is done. It&rsquo;s obvious after pointing it out, but I think it&rsquo;s fair to say that most of us thought that there would not be a problem with <code>CreateStringWithBuffer()</code>, because it looks so straightforward and simple.</p><p>Thinking about it, C++ constructors will never have this issue because you are modifying <code>this</code> and returns a reference to itself. (However, I have a lot of things against C++ constructors, which I might go into another article when I can).</p><p>Thankfully, the pointer version will not have the issue:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Simple lightweight &#39;string&#39; object.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>String</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cap;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>String <span style=color:#a6e22e>CreateString</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> buffer, <span style=color:#66d9ef>int</span> cap) {
</span></span><span style=display:flex><span>    String ret <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    ret.data <span style=color:#f92672>=</span> buffer;
</span></span><span style=display:flex><span>    ret.cap <span style=color:#f92672>=</span> cap;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StringWithBuffer</span> {
</span></span><span style=display:flex><span>    u8 buffer[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    String str; 
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>CreateStringWithBuffer</span>(StringWithBuffer<span style=color:#f92672>*</span> Foo) {
</span></span><span style=display:flex><span>    Foo<span style=color:#f92672>-&gt;</span>Str <span style=color:#f92672>=</span> CreateString(Foo<span style=color:#f92672>-&gt;</span>Buffer, <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Usage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>StringWithBuffer foo <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>CreateStringWithBuffer(<span style=color:#f92672>&amp;</span>foo);
</span></span><span style=display:flex><span><span style=color:#75715e>// foo.str.data correctly points to foo.str.buffer!
</span></span></span></code></pre></div><p>In the end, I really shouldn&rsquo;t have cared that much.</p></div></div></div></body></html>